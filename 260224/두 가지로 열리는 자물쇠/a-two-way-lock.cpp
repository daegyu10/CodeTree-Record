#include <iostream>
using namespace std;

bool InRange(int a, int b, int n) {
    int dist = (a - b + n) % n;
    if(dist <= 2 || dist >= n-2) {
        return true;
    } else {
        return false;
    }
}

int main() {
    // Please write your code here.
    //1. 출발지, 도착지로 해석해보자. 1,2,3이런걸 출발, 9,10,1,2,3같은 정답이 도착. 그러면 1-9.-8이 된다. 여기에 10. n을 더한다. 그럼 +2. abs로 2가 나온다.
    //근데 우리는 법칙을 만들어야한다. 즉, %n을 해보면 어떨까? 예를 들어, (1-9+n)%10 -> +2. (3-1+10)%10 -> 12%10 -> 2.
    //즉, (i-j+n)%n. 이걸로 해보자.
    //예전에 반시계방향 방 번호를 응용.
    //-===> 생각해보니까 이미 abs를 쓰고 있다. 근데 1,2,3주고 1,9,5를 주면? 9-2는 7이다. 거리를 어떻게 2를 뽑는가. 2에서 9를 빼도 -7이고 9에서 2를 빼도 7이다.
    //1-1은 0이다. 3-5는 -2다. abs쓰면 다 거리가 나온다. 근데 문제는 a-b에서 a가 더 클때. 원으로 연결된 이상 이건 문제다.

    //======> 4. (j-i+n)%n는 시계방향. 즉 한쪽 거리만 구해준다. 예를 들어서, 출발. 주어진 조합이 1이고 9를 맞춰본다면. 1-9+10 한다음 %10 해주면 2. 잘 나온다.
    //그런데, 주어진 조합이 9이고 1을 맞춰본다면? 9-1+10 % 10은 18 % 10. 즉 거리는 8이다. 자물쇠는 왼쪽/오른쪽으로 다 갈수 있기 때문. 원형이니까.
    //값이 증가하는 상황은 맞춰준다. 근데 값이 감소하는 상황은 잘 못맞추는 것. 
    //      1
    //   5     2
    //     4   3
    //이런 느낌일 듯. 1->5는 잘 맞춘다. 시계방향. 근데 5->1은 못한다. 반시계방향이라.
    //그렇다면 2가지를 해보자. dist와 n-dist. dist가 8이 나왔다. 그럼 그걸 n에서 빼는것. 10-8 => 2.
    //2개를 동시에 비교해보자.
    
    int n;
    cin >> n;

    int arr[6] = {};
    for(int i = 0; i < 6; i++) {
        cin >> arr[i];
    }
    //2. 1에서 9,10,1,2,3을 빼보자. -8, -9, 0, 1, 2/ => 여기에 n. 10을 더해보자. 2, 1, 10, 11, 12. %10으로 할 수 있다.
    //9,10,1,2,3에서 1을 빼보자. 8, 9, 0, 1, 2

    //
    //3. 겹치는건 어떻게 해야할까.
    //첫번째 조합을 하되, 겹치는 건 bool로 겹치는 걸 체크해보자.
    //그리고 두개를 더하고 빼는거?
    //==> 첫번째 조합 더하고, 두번재 조합 더하자. 그리고, 만약 둘 다 해당된다면. 빼기.
    int count = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            for(int k = 1; k <= n; k++) {
                bool exist1 = false;
                bool exist2 = false;

                
                if(InRange(arr[0], i, n) && InRange(arr[1], j, n) && InRange(arr[2], k, n)) {
                    count++;
                    exist1 = true;
                }

                if(InRange(arr[3], i, n) && InRange(arr[4], j, n) && InRange(arr[5], k, n)) {
                    count++;
                    exist2 = true;
                }

                if(exist1 == true && exist2 == true) {
                    count--;
                }
            }
        }
    }

    cout << count;
    return 0;
}